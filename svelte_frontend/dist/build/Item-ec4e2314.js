
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, w as svg_element, h as attr_dev, a as add_location, b as insert_dev, k as append_dev, q as noop, f as detach_dev, x as createEventDispatcher, e as element, t as text, g as space, o as create_component, p as mount_component, y as listen_dev, l as set_data_dev, m as transition_in, n as transition_out, r as destroy_component } from './main-133695a0.js';

/* node_modules/tabler-icons-svelte/dist/ClipboardList.svelte generated by Svelte v3.32.1 */

const file = "node_modules/tabler-icons-svelte/dist/ClipboardList.svelte";

function create_fragment(ctx) {
	let svg;
	let path0;
	let path1;
	let rect;
	let line0;
	let line1;
	let line2;
	let line3;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			attr_dev(path0, "stroke", "none");
			attr_dev(path0, "d", "M0 0h24v24H0z");
			attr_dev(path0, "fill", "none");
			add_location(path0, file, 19, 2, 408);
			attr_dev(path1, "d", "M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2");
			add_location(path1, file, 20, 2, 462);
			attr_dev(rect, "x", "9");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "6");
			attr_dev(rect, "height", "4");
			attr_dev(rect, "rx", "2");
			add_location(rect, file, 21, 2, 558);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "9.01");
			attr_dev(line0, "y2", "12");
			add_location(line0, file, 22, 2, 609);
			attr_dev(line1, "x1", "13");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "12");
			add_location(line1, file, 23, 2, 653);
			attr_dev(line2, "x1", "9");
			attr_dev(line2, "y1", "16");
			attr_dev(line2, "x2", "9.01");
			attr_dev(line2, "y2", "16");
			add_location(line2, file, 24, 2, 696);
			attr_dev(line3, "x1", "13");
			attr_dev(line3, "y1", "16");
			attr_dev(line3, "x2", "15");
			attr_dev(line3, "y2", "16");
			add_location(line3, file, 25, 2, 740);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", "icon icon-tabler icon-tabler-clipboard-list");
			attr_dev(svg, "width", /*size*/ ctx[0]);
			attr_dev(svg, "height", /*size*/ ctx[0]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "stroke", /*color*/ ctx[1]);
			attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[2]);
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			add_location(svg, file, 6, 0, 117);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, rect);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr_dev(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr_dev(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*color*/ 2) {
				attr_dev(svg, "stroke", /*color*/ ctx[1]);
			}

			if (dirty & /*strokeWidth*/ 4) {
				attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ClipboardList", slots, []);
	let { size = 24 } = $$props;
	let { color = "currentColor" } = $$props;
	let { strokeWidth = 2 } = $$props;
	const writable_props = ["size", "color", "strokeWidth"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ClipboardList> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("strokeWidth" in $$props) $$invalidate(2, strokeWidth = $$props.strokeWidth);
	};

	$$self.$capture_state = () => ({ size, color, strokeWidth });

	$$self.$inject_state = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("strokeWidth" in $$props) $$invalidate(2, strokeWidth = $$props.strokeWidth);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, color, strokeWidth];
}

class ClipboardList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { size: 0, color: 1, strokeWidth: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClipboardList",
			options,
			id: create_fragment.name
		});
	}

	get size() {
		throw new Error("<ClipboardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<ClipboardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<ClipboardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<ClipboardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strokeWidth() {
		throw new Error("<ClipboardList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strokeWidth(value) {
		throw new Error("<ClipboardList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/tabler-icons-svelte/dist/Pencil.svelte generated by Svelte v3.32.1 */

const file$1 = "node_modules/tabler-icons-svelte/dist/Pencil.svelte";

function create_fragment$1(ctx) {
	let svg;
	let path0;
	let path1;
	let line;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			line = svg_element("line");
			attr_dev(path0, "stroke", "none");
			attr_dev(path0, "d", "M0 0h24v24H0z");
			attr_dev(path0, "fill", "none");
			add_location(path0, file$1, 19, 2, 400);
			attr_dev(path1, "d", "M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4");
			add_location(path1, file$1, 20, 2, 454);
			attr_dev(line, "x1", "13.5");
			attr_dev(line, "y1", "6.5");
			attr_dev(line, "x2", "17.5");
			attr_dev(line, "y2", "10.5");
			add_location(line, file$1, 21, 2, 521);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", "icon icon-tabler icon-tabler-pencil");
			attr_dev(svg, "width", /*size*/ ctx[0]);
			attr_dev(svg, "height", /*size*/ ctx[0]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "stroke", /*color*/ ctx[1]);
			attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[2]);
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			add_location(svg, file$1, 6, 0, 117);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr_dev(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr_dev(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*color*/ 2) {
				attr_dev(svg, "stroke", /*color*/ ctx[1]);
			}

			if (dirty & /*strokeWidth*/ 4) {
				attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Pencil", slots, []);
	let { size = 24 } = $$props;
	let { color = "currentColor" } = $$props;
	let { strokeWidth = 2 } = $$props;
	const writable_props = ["size", "color", "strokeWidth"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pencil> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("strokeWidth" in $$props) $$invalidate(2, strokeWidth = $$props.strokeWidth);
	};

	$$self.$capture_state = () => ({ size, color, strokeWidth });

	$$self.$inject_state = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("strokeWidth" in $$props) $$invalidate(2, strokeWidth = $$props.strokeWidth);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, color, strokeWidth];
}

class Pencil extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { size: 0, color: 1, strokeWidth: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pencil",
			options,
			id: create_fragment$1.name
		});
	}

	get size() {
		throw new Error("<Pencil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Pencil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Pencil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Pencil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strokeWidth() {
		throw new Error("<Pencil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strokeWidth(value) {
		throw new Error("<Pencil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/tabler-icons-svelte/dist/Trash.svelte generated by Svelte v3.32.1 */

const file$2 = "node_modules/tabler-icons-svelte/dist/Trash.svelte";

function create_fragment$2(ctx) {
	let svg;
	let path0;
	let line0;
	let line1;
	let line2;
	let path1;
	let path2;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr_dev(path0, "stroke", "none");
			attr_dev(path0, "d", "M0 0h24v24H0z");
			attr_dev(path0, "fill", "none");
			add_location(path0, file$2, 19, 2, 399);
			attr_dev(line0, "x1", "4");
			attr_dev(line0, "y1", "7");
			attr_dev(line0, "x2", "20");
			attr_dev(line0, "y2", "7");
			add_location(line0, file$2, 20, 2, 453);
			attr_dev(line1, "x1", "10");
			attr_dev(line1, "y1", "11");
			attr_dev(line1, "x2", "10");
			attr_dev(line1, "y2", "17");
			add_location(line1, file$2, 21, 2, 493);
			attr_dev(line2, "x1", "14");
			attr_dev(line2, "y1", "11");
			attr_dev(line2, "x2", "14");
			attr_dev(line2, "y2", "17");
			add_location(line2, file$2, 22, 2, 536);
			attr_dev(path1, "d", "M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12");
			add_location(path1, file$2, 23, 2, 579);
			attr_dev(path2, "d", "M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3");
			add_location(path2, file$2, 24, 2, 641);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", "icon icon-tabler icon-tabler-trash");
			attr_dev(svg, "width", /*size*/ ctx[0]);
			attr_dev(svg, "height", /*size*/ ctx[0]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "stroke", /*color*/ ctx[1]);
			attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[2]);
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			add_location(svg, file$2, 6, 0, 117);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, path1);
			append_dev(svg, path2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				attr_dev(svg, "width", /*size*/ ctx[0]);
			}

			if (dirty & /*size*/ 1) {
				attr_dev(svg, "height", /*size*/ ctx[0]);
			}

			if (dirty & /*color*/ 2) {
				attr_dev(svg, "stroke", /*color*/ ctx[1]);
			}

			if (dirty & /*strokeWidth*/ 4) {
				attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Trash", slots, []);
	let { size = 24 } = $$props;
	let { color = "currentColor" } = $$props;
	let { strokeWidth = 2 } = $$props;
	const writable_props = ["size", "color", "strokeWidth"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Trash> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("strokeWidth" in $$props) $$invalidate(2, strokeWidth = $$props.strokeWidth);
	};

	$$self.$capture_state = () => ({ size, color, strokeWidth });

	$$self.$inject_state = $$props => {
		if ("size" in $$props) $$invalidate(0, size = $$props.size);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("strokeWidth" in $$props) $$invalidate(2, strokeWidth = $$props.strokeWidth);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, color, strokeWidth];
}

class Trash extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { size: 0, color: 1, strokeWidth: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Trash",
			options,
			id: create_fragment$2.name
		});
	}

	get size() {
		throw new Error("<Trash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Trash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Trash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Trash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strokeWidth() {
		throw new Error("<Trash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strokeWidth(value) {
		throw new Error("<Trash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/Item.svelte generated by Svelte v3.32.1 */
const file$3 = "src/pages/Item.svelte";

function create_fragment$3(ctx) {
	let item;
	let info;
	let h2;
	let t0;
	let t1;
	let p;
	let t2;
	let t3;
	let controls;
	let pencil;
	let t4;
	let trash;
	let t5;
	let shortcut;
	let clipboardlist;
	let current;
	let mounted;
	let dispose;
	pencil = new Pencil({ $$inline: true });
	trash = new Trash({ $$inline: true });
	clipboardlist = new ClipboardList({ $$inline: true });

	const block = {
		c: function create() {
			item = element("item");
			info = element("info");
			h2 = element("h2");
			t0 = text(/*courseName*/ ctx[0]);
			t1 = space();
			p = element("p");
			t2 = text(/*courseText*/ ctx[1]);
			t3 = space();
			controls = element("controls");
			create_component(pencil.$$.fragment);
			t4 = space();
			create_component(trash.$$.fragment);
			t5 = space();
			shortcut = element("shortcut");
			create_component(clipboardlist.$$.fragment);
			add_location(h2, file$3, 14, 4, 348);
			add_location(p, file$3, 15, 4, 374);
			add_location(controls, file$3, 16, 4, 398);
			attr_dev(info, "class", "svelte-oql3zf");
			add_location(info, file$3, 13, 2, 337);
			add_location(shortcut, file$3, 22, 2, 471);
			attr_dev(item, "class", "svelte-oql3zf");
			add_location(item, file$3, 12, 0, 312);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, item, anchor);
			append_dev(item, info);
			append_dev(info, h2);
			append_dev(h2, t0);
			append_dev(info, t1);
			append_dev(info, p);
			append_dev(p, t2);
			append_dev(info, t3);
			append_dev(info, controls);
			mount_component(pencil, controls, null);
			append_dev(controls, t4);
			mount_component(trash, controls, null);
			append_dev(item, t5);
			append_dev(item, shortcut);
			mount_component(clipboardlist, shortcut, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(item, "click", /*test*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*courseName*/ 1) set_data_dev(t0, /*courseName*/ ctx[0]);
			if (!current || dirty & /*courseText*/ 2) set_data_dev(t2, /*courseText*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pencil.$$.fragment, local);
			transition_in(trash.$$.fragment, local);
			transition_in(clipboardlist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pencil.$$.fragment, local);
			transition_out(trash.$$.fragment, local);
			transition_out(clipboardlist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(item);
			destroy_component(pencil);
			destroy_component(trash);
			destroy_component(clipboardlist);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Item", slots, []);
	let { courseName } = $$props;
	let { courseText } = $$props;
	const dispatch = createEventDispatcher();

	function test() {
		dispatch("onClick", { text: courseName });
	}

	const writable_props = ["courseName", "courseText"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("courseName" in $$props) $$invalidate(0, courseName = $$props.courseName);
		if ("courseText" in $$props) $$invalidate(1, courseText = $$props.courseText);
	};

	$$self.$capture_state = () => ({
		Pencil,
		Trash,
		ClipboardList,
		createEventDispatcher,
		courseName,
		courseText,
		dispatch,
		test
	});

	$$self.$inject_state = $$props => {
		if ("courseName" in $$props) $$invalidate(0, courseName = $$props.courseName);
		if ("courseText" in $$props) $$invalidate(1, courseText = $$props.courseText);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [courseName, courseText, test];
}

class Item extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { courseName: 0, courseText: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Item",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*courseName*/ ctx[0] === undefined && !("courseName" in props)) {
			console.warn("<Item> was created without expected prop 'courseName'");
		}

		if (/*courseText*/ ctx[1] === undefined && !("courseText" in props)) {
			console.warn("<Item> was created without expected prop 'courseText'");
		}
	}

	get courseName() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set courseName(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get courseText() {
		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set courseText(value) {
		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Item;
//# sourceMappingURL=Item-ec4e2314.js.map
